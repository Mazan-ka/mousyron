 грамматика для парсера
 WHILE_KW -> "while"
 OP -> ">" | "<" | "=="
 VAR_BUL -> TRUE | FALSE
 START_WHILE -> "\\{"
 FINISH_WHILE -> "\\}"
 L_BR -> "\\("
 R_BR -> "\\)"

ОСНОВНАЯ ГРАММАТИКА
 lang -> expr+
 expr+ -> assign | while_keyword
 assign -> VAR ASSIGN_OP expr_value       a=5+3    var assign_op digit op digit
 expr_value -> value (op_value)*
 op_value -> OP value
 value -> DIGIT | VAR


 while_keyword -> WHILE_KW condition_while body_while
 condition_while -> \\( compare \\) | \\( VAR_BOOL \\)
 body_while -> START_WHILE expr+ FINISH_WHILE
 compare -> value OP value

 void expr() {
   VAR();
   ASSIGN_OP();
   expr_value();
 }

 void VAR() {
   проверка типа на VAR берю с помощью match след токен
   если нет, то выдать исключение
 }

  #Грамматика бесконечных скобок:
  expr_value -> inf_Parenthesis_val | val_inf_Parenthesis -- заменяет обычный expr_value
  inf_Parenthesis_val -> L_BR parenthesis_expr_value R_BR (OP expr_value)*
  val_inf_Parenthesis -> value (OP (value | inf_Parenthesis) )*
  parenthesis_expr_value -> inf_Parenthesis | (value (OP (value | inf_Parenthesis) )+)

  Проверка:
  a = 7 * (100 + b)
  b = (7 + c) * a
  a = ((100 + b) * (100 + 3)) * (a + c)

  Сначала из  инфиксной формы в постфиксную алгоритмом дейкстры, далее после преобразования в стек машину для вычисления
    a = a + 1 + 3 - 100 + 4  ->  a a 1 + 3 + 100 - 4 + =

  Полис для if/for/while:
  p! - метка безусловный переход на метку p
  bp!F - условный переход по лжи, b - boolean

  if (a>b) {a=1} else {b=4} ->
  ab > p1!F a1= p2! b 4 = t (перевёрнутая, признак конца полиса)
  01 2 3 4  567 8 9 10111213
